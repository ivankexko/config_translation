################################################################################
# ПРИМЕЧАНИЕ: Не изменяйте этот файл для настройки ocserv. Добавьте новые
# директивы в /etc/ocserv/ocserv.conf.local, и они будут включены в конфигурацию
# ocserv
################################################################################

# Метод аутентификации пользователя. Может быть установлен несколько раз, и в
# этом случае все должно пройти успешно.
# Варианты: certificate, pam. 
#auth = "certificate"
#auth = "pam"

# Параметр gid-min используется параметром auto-select-group для выбора
# минимального идентификатора группы.
#auth = "pam[gid-min=1000]"

# Для простого варианта требуется указать файл паролей, содержащий записи
# следующего формата.
# "username:groupname:encoded-password"
# В каждой строке должна быть указана одна запись, а для генерации паролей можно
# использовать "ocpasswd".
auth = "|AUTH|"

# Баннер, который будет отображаться на клиентах после подключения
banner = "Welcome to OpenWRT"

# Баннер, который будет отображаться на клиентах перед подключением
#pre-login-banner = "Welcome"

#isolate-workers = true

# Если у сервера динамический DNS-адрес (который может измениться), следует
# установить его в значение true, чтобы запросить у клиента повторное разрешение
# при повторном подключении.
listen-host-is-dyndns = |DYNDNS|

# Используйте listen-host, чтобы ограничиться определенными IP-адресами или
# IP-адресами указанного имени хоста.
#listen-host = [IP|HOSTNAME]

# Ограничить количество клиентов.
# Используйте ноль для неограниченного количества.
#max-clients = 1024
max-clients = |MAX_CLIENTS|

# Установите ограничение на количество входящих подключений до одного клиента
# каждые X миллисекунд (X - это указанное значение) по мере увеличения второго
# периода ожидания. Это повышает устойчивость сервера (и предотвращает сбои
# соединения) при нескольких одновременных подключениях. Установите нулевое
# значение, чтобы не было ограничений.
rate-limit-ms = 100

# Ограничьте количество одинаковых клиентов (т.е. пользователей, подключающихся
# несколько раз).
# Используйте ноль для неограниченного количества.
max-same-clients = |MAX_SAME|

# Номер порта TCP и UDP
tcp-port = |PORT|
|UDP|udp-port = |UDP_PORT|

# Время отчета о состоянии. Количество секунд, по истечении которых каждый
# рабочий процесс будет сообщать статистику своего использования (количество
# переданных байт и т.д.). Это полезно, если используется учет, подобный radius.
#stats-report-time = 360

# Время сброса статистики. Будет сброшена статистика за период времени,
# сохраняемый основным/вторым процессами. Это статистика, отображаемая командой
# "occtl show stats". За день: 86400, за неделю: 604800
# Это никак не связано со временем составления отчета о состоянии.
server-stats-reset-time = 604800

# Подержания активности через указанный период в секундах.
keepalive = 32400

# Обнаружение мертвого peer за считанные секунды.
dpd = |DPD|

# Обнаружение мертвого peer для мобильных клиентов. Требования должны быть
# намного выше, чтобы такие клиенты не слишком часто просыпались из-за сообщений
# DPD для экономии заряда батареи
# (клиенты, отправляющие X-AnyConnect-Identifier-DeviceType).
mobile-dpd = 1800

# Если используется протокол DTLS, а UDP-трафик не поступает в течение данного
# количества секунд, попробовать вместо этого отправить будущий трафик по
# TCP-соединению, чтобы попытаться разбудить клиента в случае, если есть NAT и
# трансляция UDP была удалена. Если этот параметр не установлен, этот механизм
# восстановления использоваться не будет.
switch-to-tcp-timeout = 25

# Обнаружение MTU (DPD должен быть включен)
try-mtu-discovery = false

#### Ключ и сертификаты сервера
# Ключом может быть файл или любой URL-адрес, поддерживаемый GnuTLS (например,
# tpmkey:uuid=xxxxxxx-xxxx-xxxx-xxxx-xxxxxxxx;storage=user or
# pkcs11:object=my-vpn-key;object-type=private)
#
# Может быть несколько пар сертификатов и ключей, и каждый ключ должен
# соответствовать предыдущему сертификату.
server-cert = /etc/ocserv/server-cert.pem
server-key = /etc/ocserv/server-key.pem

# Параметры Diffie-Hellman. Требуется только в том случае, если вам требуется
# поддержка наборов шифров DHE (по умолчанию этот сервер поддерживает ECDHE).
# Может быть сгенерирован с помощью:
# certtool --generate-dh-params --outfile /path/to/dh.pem
#dh-params = /path/to/dh.pem

# Если у вас есть сертификат от центра сертификации, предоставляющего службу
# OCSP, вы можете предоставить новый ответ о статусе OCSP в рамках подтверждения
# TLS. Это предотвратит независимое подключение клиента к серверу OCSP.
# Вы можете периодически обновлять этот ответ с помощью:
# ocsptool --ask --load-cert=your_cert --load-issuer=your_ca --outfile response
# Убедитесь, что вы заменили следующий файл атомарным способом.
#ocsp-response = /path/to/ocsp.der

# В случае использования ключей PKCS #11 или доверенного платформенного модуля,
# PIN-коды должны быть доступны в файлах. Файл srk-pin применим только к ключам
# доверенного платформенного модуля и является корневым ключом хранилища.
#pin-file = /path/to/pin.txt
#srk-pin-file = /path/to/srkpin.txt

# Центр сертификации, который будет использоваться для проверки клиентских 
# сертификатов (открытых ключей), если установлена проверка подлинности по
# сертификату.
#ca-cert = /etc/ocserv/ca.pem

# Идентификатор объекта, который будет использоваться для считывания
# идентификатора пользователя в клиентском сертификате. Идентификатор объекта
# должен быть частью DN сертификата.
# Полезными OID являются:
# CN = 2.5.4.3, UID = 0.9.2342.19200300.100.1.1
#cert-user-oid = 0.9.2342.19200300.100.1.1

# Идентификатор объекта, который будет использоваться для определения группы
# пользователей в клиентском сертификате. Идентификатор объекта должен быть
# частью DN сертификата. Полезными OID являются:
#  OU (organizational unit) = 2.5.4.11 
#cert-group-oid = 2.5.4.11

# Список аннулированных сертификатов, выданных вышеуказанным "ca-cert".
#crl = /etc/ocserv/crl.pem

# Раскомментируйте это, чтобы включить согласование сжатия (LZS, LZ4).
|COMPRESSION|compression = true

# Строка приоритета GnuTLS
tls-priorities = "NORMAL:%SERVER_PRECEDENCE:%COMPAT:-VERS-SSL3.0"

# Для обеспечения идеальной прямой секретности (PFS) на главном канале.
#tls-priorities = "NORMAL:%SERVER_PRECEDENCE:%COMPAT:-VERS-SSL3.0:-RSA"

# Время (в секундах), в течение которого клиенту разрешается оставаться на связи
# до прохождения аутентификации.
auth-timeout = 240

# Время (в секундах), в течение которого клиент может находиться в режиме
# ожидания (без трафика) перед отключением.
# Снимите флажок отключить.
#idle-timeout = 1200

# Время (в секундах), в течение которого мобильному клиенту разрешается 
# оставаться в режиме ожидания (без трафика) перед отключением.
# Снимите флажок отключить.
#mobile-idle-timeout = 2400

# Время (в секундах), в течение которого клиенту не разрешается повторно
# подключаться после неудачной попытки аутентификации.
min-reauth-time = 360

# Блокировка клиентов в ocserv работает по системе начисления баллов. IP-адреса,
# которые набирают количество баллов, превышающее указанное в настройках,
# блокируются на минимальное время авторизации. По умолчанию за неверную попытку
# ввода пароля начисляется 10 баллов, за сообщение KKDCP - 1 балл, а за
# подключение - 1 балл. Обратите внимание, что из-за различий в используемых
# процессах подсчет баллов не будет точным в режиме реального времени.
#
# Запрет Score не может быть надежно использован при получении прокси-соединений
# локально с HTTP-сервера (т.е. когда используется функция listen-clear-file).
#
# Установите значение "ноль" для отключения.
max-ban-score = 80

# Время (в секундах), в течение которого все оценки, сохраненные для клиента,
# сбрасываются.
ban-reset-time = 1200

# На случай, если вы захотите изменить значения по умолчанию.
#ban-points-wrong-password = 10
#ban-points-connection = 1
#ban-points-kkdcp = 1

# Время ожидания файлов cookie (в секундах)
# Как только клиент проходит аутентификацию, ему предоставляется файл cookie, с
# помощью которого он может повторно подключиться. Этот файл cookie будет
# признан недействительным, если не будет использован в течение этого времени
# ожидания. Этот файл cookie остается действительным в течение времени
# подключения пользователя, а после отключения пользователя он остается активным
# в течение этого периода времени. Эта настройка должна обеспечивать разумный
# промежуток времени для перемещения между различными сетями.
cookie-timeout = 300

# Если эта функция включена (не рекомендуется), файлы cookie будут оставаться
# действительными даже после того, как пользователь отключится вручную, и до
# истечения срока их действия. Это может улучшить роуминг с некоторыми
# неработающими клиентами.
#persistent-cookies = true

# Запрещен ли роуминг, т.е. если это значение равно true, файл cookie ограничен
# одним IP-адресом и не может быть повторно использован с другого IP-адреса.
deny-roaming = false

# Время повторного ввода (в секундах) ocserv будет запрашивать у клиента
# периодическое обновление ключей по истечении этого времени. Установите нулевое
# значение для отключения (обратите внимание, что некоторые клиенты выходят из
# строя, если rekey отключен).
rekey-time = 172800

# Метод повторного подключения
# Допустимые параметры: ssl, new-tunnel
#  ssl: Выполнит эффективное повторное подключение к каналу, обеспечивая
#    бесперебойное соединение во время повторного подключения.
# new-tunnel: Даст указание клиенту отменить и восстановить канал. Используйте
#    эту опцию только в том случае, если у подключающихся клиентов возникают
#    проблемы с опцией ssl.
rekey-method = ssl

# Скрипт, вызываемый при подключении клиента и получении IP-адреса
# Следующие параметры передаются в среду выполнения скрипта:
# REASON - событие, может быть "подключение" или "отключение";
# USERNAME - имя пользовтеля;
# GROUPNAME - имя группы;
# HOSTNAME - имя хоста, выбранное клиентом; 
# DEVICE - устройство;
# IP_REAL - реальный IP клиента;
# IP_LOCAL - локальный IP в PtP-соединении;
# IP_REMOTE - VPN-IP клиента;
# ID - уникальный цифровой идентификатор.

# Эти скрипты не нужны, если вы настроили интерфейс для всех устройств vpn+.
#connect-script = /usr/bin/ocserv-script
#disconnect-script = /usr/bin/ocserv-script

# UTMP позволяет получать информацию о том, кто в данный момент подключен.
use-utmp = false

# Следует ли включить поддержку инструмента occt (т.е. либо через DBUS, либо через сокет unix).
use-occtl = true

# Файл сокета, используемый для IPC с occt. Вам нужно установить это значение
# только в том случае, если вы используете более одного сервера.
occtl-socket-file = /var/run/occtl.socket

# PID-файл. Его можно переопределить в командной строке.
pid-file = /var/run/ocserv.pid

# Каталог сервера по умолчанию. Для этого не требуется наличие каких-либо
# устройств.
chroot-dir = /var/lib/ocserv

# к файлу сокета, используемому для IPC, будет добавлен .PID
# Он должен быть доступен в среде chroot (если таковая имеется).
#socket-file = /var/run/ocserv-socket
socket-file = ocserv-socket

# Пользователь, от имени которого будут запускаться рабочие процессы. Он должен
# быть уникальным (никакие другие службы не запускаются от имени этого
# пользователя).
run-as-user = ocserv
run-as-group = ocserv

# Установите приоритет, определенный протоколом (SO_PRIORITY) для отправляемых
# пакетов. Это число от 0 до 6, где 0 - самый низкий приоритет. В качестве
# альтернативы это можно использовать для настройки IP Type-Of-Service,
# установив для него шестнадцатеричное число (например, 0x20).
# Это можно задать для каждого пользователя/группы или глобально.
#net-priority = 3

# Выделите рабочий процесс VPN в определенную группу. Это зависит от Linux и
# может быть настроено для каждого пользователя/группы или глобально.
#cgroup = "cpuset,cpu:test"

#
# Сетевые настройки
#

# Название устройства tun
device = vpns

################################################################################
# Будут ли сгенерированные IP-адреса предсказуемыми, т.е. IP-адрес останется
# неизменным для одного и того же пользователя, когда это возможно.
predictable-ips = |PREDICTABLE_IPS|

# Домен по умолчанию, который будет объявлен
|ENABLE_DEFAULT_DOMAIN|default-domain = |DEFAULT_DOMAIN|

# Список адресов, с которых будут выдаваться договоры аренды.
ipv4-network = |IPV4ADDR|
ipv4-netmask = |NETMASK|

# Транслируемый DNS-сервер. Используйте несколько строк для нескольких серверов.
#dns = fc00::4be0
#dns = 192.168.1.2

# Сервер NBNS (если таковой имеется)
#nbns = 192.168.1.3

# Будет указана подсеть IPv6, из которой будет осуществляться аренда.
|ENABLE_IPV6|ipv6-network = |IPV6ADDR|

# Домены, для которых следует использовать предоставленный DNS. Используйте
# несколько строк для нескольких доменов.
|ENABLE_SPLIT_DNS|split-dns = |DEFAULT_DOMAIN|

# Прежде чем арендовать какой-либо IP-адрес из пула, пропингуйте его, чтобы
# убедиться, что он не используется другим устройством (не связанным с этим
# сервером) хостом.
ping-leases = |PING_LEASES|

# Следует ли туннелировать все DNS-запросы через VPN. Это значение используется
# по умолчанию, если задан маршрут по умолчанию.
#tunnel-all-dns = true

# Снимите настройку, чтобы назначить MTU устройства по умолчанию
# mtu = 

# Снимите флажок, чтобы включить ограничения по пропускной способности
# (в байтах/сек). Данная настройка является глобальной, но также может быть
# установлена для каждого пользователя или группы.
#rx-data-per-sec = 40000
#tx-data-per-sec = 40000

# Количество пакетов (размером MTU), доступных в выходном буфере. Значение по
# умолчанию низкое для уменьшения задержки. Если установить его выше, это
# повысит пропускную способность.
#output-buffer = 10

# Маршруты, которые будут перенаправлены клиенту. Если вам нужно, чтобы клиент
# перенаправлял маршруты на сервер, вы можете использовать настройки для каждого
# пользователя/группы или даже сценарии подключения и отключения.
#
# Чтобы установить сервер в качестве шлюза по умолчанию для клиента, просто
# закомментируйте все маршруты с сервера.
#route = 192.168.1.0/255.255.255.0
#route = 192.168.5.0/255.255.255.0
#route = fef4:db8:1000:1001::/64

# Файлы конфигурации, которые будут применяться для каждого подключения
# пользователя или для каждой группы. Имя каждого файла в этих каталогах должно
# совпадать с именем пользователя или группы.
# В файлах конфигурации разрешены следующие параметры:
#   dns, nbns, ipv?-network, ipv4-netmask, ipv6-prefix, rx/tx-per-sec, iroute,
#   route, net-priority и cgroup.
#
# Обратите внимание, что опция "route" позволяет добавлять маршруты на сервер в
# зависимости от пользователя или группы. Синтаксис зависит от ввода,
# принимаемого командами route-add-cmd и route-del-cmd (см. ниже).
config-per-user = /etc/ocserv/config-per-user/
config-per-group = /etc/ocserv/config-per-group/

# Если задан параметр config-per-xxx и нет подходящей группы или пользователя,
# то используйте следующую конфигурацию.

#default-user-config = /etc/ocserv/defaults/user.conf
#default-group-config = /etc/ocserv/defaults/group.conf

# Группы, из которых клиенту разрешено выбирать.
# Клиент может принадлежать к нескольким группам, и в определенных случаях
# использования необходимо переключаться между ними. В этих случаях клиент может
# выбирать перед аутентификацией. Добавьте несколько записей для нескольких
# групп.
#select-group = group1
#select-group = group2[My group 2]
#select-group = tost[The tost group]

# Имя группы, которая, если будет выбрана, позволит использовать назначенную по
# умолчанию группу.
#default-select-group = DEFAULT

# Вместо того, чтобы вручную указывать все разрешенные группы, вы можете
# поручить ocserv проверить все доступные группы и включить полный список. Эта
# опция работает только при обычной аутентификации.
#auto-select-group = true

# Системная команда, используемая для настройки маршрута. %{R} будет заменен на
# route/mask, а %{D} - на (tun) device.
#
# Следующий пример взят из систем Linux. %{R} должно быть как 192.168.2.0/24
#route-add-cmd = "/usr/sbin/ip route add %{R} dev %{D}"
#route-del-cmd = "/usr/sbin/ip route delete %{R} dev %{D}"

route-add-cmd = "/sbin/route add -net %{RI} dev %{D}"
route-del-cmd = "/sbin/route del -net %{RI} dev %{D}"

# Эта опция позволяет перенаправлять прокси-сервер. Специальные строки "%{U}" и
# "%{G}", если они присутствуют, будут заменены на имя пользователя и название
# группы.
#proxy-url = http://example.com/
#proxy-url = http://example.com/%{U}/%{G}/hello

#
# Следующие параметры предназначены для (экспериментальной) совместимости с
# клиентом AnyConnect.

# XML-файл профиля клиента. Примерный файл существует в doc/profile.xml. Этот
# файл должен быть доступен из chroot-файла пользователя. Он не используется
# клиентом openconnect.
#user-profile = profile.xml

# Двоичные файлы, которые могут быть загружены клиентом CISCO. Должны находиться
# в любой среде chroot.
#binary-files = /path/to/binaries

# Если не установлено значение false, клиентам необходимо предоставить свой
# сертификат, даже если они проходят аутентификацию с помощью ранее
# предоставленного файла cookie и завершают аутентификацию в том же
# TCP-соединении.
# Устаревшие клиенты CISCO этого не делают, и, следовательно, для них следует
# установить эту опцию.
cisco-client-compat = |CISCO_COMPAT|

# Расширенные параметры

# Возможность разрешить отправку произвольных пользовательских заголовков
# клиенту после аутентификации и до создания VPN-туннеля.
#custom-header = "X-My-Header: hi there"

expose-iroutes = true

# Уровень журнала. Ocserv отправляет сообщения журнала в standard error, а также
# в системный журнал. Уровень журнала можно изменить в командной строке с
# помощью параметра -d. Будут отображаться все сообщения на настроенном уровне
# и ниже. Поддерживаемые уровни (по умолчанию 0):
#   0 default (то же, что и basic)
#   1 basic
#   2 info
#   3 debug
#   4 http
#   8 sensitive
#   9 TLS
log-level = 3

# Эта опция активирует протокол обхода X-CSTP-Client-Bypass-Protocol (по
# умолчанию отключен). Если сервер не настроил пул адресов IPv6 или IPv4,
# включение этой опции позволит клиенту обойти сервер по этому IP-протоколу.
# В настоящее время эта опция доступна только клиентам Anyconnect.
client-bypass-protocol = false

# Следующие опции относятся к маскировке сервера (скрытому сервису)

# Эта опция позволяет вам включить функцию маскировки ocserv, которая делает его
# похожим на веб-сервер для посторонних лиц. При включенном "камуфляже"
# подключение к VPN может быть установлено только в том случае, если клиент
# указал определенную "секретную строку" в URL-адресе подключения, например:
# https://example.com/?mysecretkey
# в противном случае сервер будет возвращать HTTP-ошибку для всех запросов.
camouflage = false

# Префикс URL-адреса, который может быть установлен на клиенте (после знака "?")
# для прохождения проверки маскировки, например, в случае "mysecretkey"
# URL-адрес сервера на клиенте должен быть похож на:
# https://example.com/?mysecretkey
camouflage_secret = "mysecretkey"

# Определяет область (запрос браузера) для HTTP-аутентификации. Если область не
# задана, сервер вернет ошибку 404 Not found вместо 401 Unauthorized. Лучше
# изменить значение по умолчанию, чтобы избежать обнаружения отпечатков пальцев.
camouflage_realm = "Restricted Content"

# HTTP headers
included-http-headers = Strict-Transport-Security: max-age=31536000 ; includeSubDomains
included-http-headers = X-Frame-Options: deny
included-http-headers = X-Content-Type-Options: nosniff
included-http-headers = Content-Security-Policy: default-src 'none'
included-http-headers = X-Permitted-Cross-Domain-Policies: none
included-http-headers = Referrer-Policy: no-referrer
included-http-headers = Clear-Site-Data: "cache","cookies","storage"
included-http-headers = Cross-Origin-Embedder-Policy: require-corp
included-http-headers = Cross-Origin-Opener-Policy: same-origin
included-http-headers = Cross-Origin-Resource-Policy: same-origin
included-http-headers = X-XSS-Protection: 0
included-http-headers = Pragma: no-cache
included-http-headers = Cache-control: no-store, no-cache
